# F组子组左右对调功能 - 可行性评估报告

## 一、可行性评估

### ✅ 技术可行

经过深入分析，当前系统架构**支持**实现F组内子组的左右对调功能。

---

## 二、现有系统架构分析

### 2.1 当前实现机制

**现有 `swapFGroupSubgroups` 函数**：
- 更新 `groupIds` 数组（轮询逻辑：最后一个移到第一个）
- 调用 `toggleFGroup` 刷新UI
- **问题**：`toggleFGroup` 只处理显示/隐藏，没有处理**顺序**！

**关键代码位置**：
- `src/models/ViewState.ts:1125-1153` - swapFGroupSubgroups 函数
- `src/services/AutoResizeLayout.ts` - 布局调整服务

### 2.2 布局调整逻辑

`autoResizeLayout` 的当前逻辑：
- 根据 `hiddenGroups` 隐藏/显示组
- 计算可见组的数量，均分 flex 空间
- **缺陷**：只调整 flex 属性，不重新排序 DOM 元素

---

## 三、核心技术方案

### 3.1 实现原理

基于Obsidian的Workspace API，可以直接操作子组的顺序：

```typescript
// 可用的API
parent.children                          // 子组数组，可以重新排序
parent.insertChild(index, leaf)          // 在指定位置插入子组
```

### 3.2 核心算法

**步骤1**：获取当前F组的 `groupIds` 顺序
**步骤2**：遍历workspace，定位每个子组对应的DOM元素
**步骤3**：按照 `groupIds` 顺序，重新排列DOM元素位置

---

## 四、具体实现步骤

### 步骤1：修改 swapFGroupSubgroups 函数

```typescript
swapFGroupSubgroups: () => {
  const { fGroups, activeFGroupId } = get();
  if (!activeFGroupId) return;
  
  const activeFGroup = fGroups[activeFGroupId];
  if (!activeFGroup || activeFGroup.groupIds.length < 2) return;
  
  // 轮询：将最后一个子组移动到第一个位置
  const newGroupIds = [...activeFGroup.groupIds];
  const lastGroupId = newGroupIds.pop();
  if (lastGroupId) {
    newGroupIds.unshift(lastGroupId);
  }
  
  // 更新状态
  const newFGroups = { ...fGroups };
  newFGroups[activeFGroupId] = {
    ...activeFGroup,
    groupIds: newGroupIds,
  };
  set({ fGroups: newFGroups });
  saveTabGroups(newFGroups);
  
  // 核心：重新排列DOM子组顺序
  reorderFGroupChildren(newGroupIds);
  
  // 触发布局更新
  autoResizeLayout(app);
}
```

### 步骤2：实现 reorderFGroupChildren 函数

```typescript
function reorderFGroupChildren(groupIds: string[]) {
  const workspace = app.workspace;
  const rootSplit = workspace.rootSplit;
  
  // 遍历workspace树，找到包含这些子组的split
  function reorderInSplit(split: WorkspaceParent) {
    const splitEl = split.containerEl;
    if (!splitEl?.classList.contains('workspace-split')) return;
    
    // 获取当前split中可见的子组
    const children = split.children as WorkspaceParent[];
    const visibleChildren = children.filter(child => {
      return groupIds.includes(child.id);
    });
    
    // 按groupIds顺序重新排列
    const orderedChildren = groupIds
      .map(id => children.find(c => c.id === id))
      .filter(Boolean) as WorkspaceParent[];
    
    // 重新插入到DOM
    orderedChildren.forEach((child, index) => {
      const currentIndex = children.indexOf(child);
      if (currentIndex !== index) {
        split.children.splice(currentIndex, 1);
        split.children.splice(index, 0, child);
        child.setParent(split);
      }
    });
    
    // 递归处理子split
    children.forEach(child => {
      if (child instanceof WorkspaceParent) {
        reorderInSplit(child);
      }
    });
  }
  
  if (rootSplit) {
    reorderInSplit(rootSplit);
  }
  
  workspace.onLayoutChange();
}
```

---

## 五、技术风险评估

### 5.1 潜在风险

| 风险项 | 风险等级 | 应对措施 |
|--------|----------|----------|
| 嵌套split处理 | 中 | 递归遍历所有层级 |
| 状态一致性 | 低 | 配合 autoResizeLayout |
| 性能影响 | 低 | 只在用户触发时执行 |

### 5.2 兼容性

- 不修改Obsidian内部状态
- 只操作DOM和workspace.children数组
- 与现有功能兼容

---

## 六、替代/优化方案

### 方案A（推荐）：直接DOM重排
- 实现 `reorderFGroupChildren` 函数
- 在 swapFGroupSubgroups 中调用

### 方案B：利用现有动画
- 暂时隐藏 → 重新排序 → 显示
- 利用过渡动画，可能有视觉反馈

---

## 七、结论

**功能完全可行**，建议采用方案A实现。预计开发工作量：约30-60分钟。

是否确认执行此方案？